# JSP include文の違い

- [JSP include文の違い](#jsp-include文の違い)
  - [質問](#質問)
  - [回答](#回答)
  - [🧩 1. 静的インクルード（`<%@ include file="..." %>`）](#-1-静的インクルード-include-file-)
    - [📖 構文](#-構文)
    - [🔍 特徴](#-特徴)
    - [⚙️ 動作のイメージ](#️-動作のイメージ)
    - [✅ メリット](#-メリット)
    - [⚠️ デメリット](#️-デメリット)
  - [⚡ 2. 動的インクルード（`<jsp:include page="..." />`）](#-2-動的インクルードjspinclude-page-)
    - [📖 構文](#-構文-1)
    - [🔍 特徴](#-特徴-1)
    - [⚙️ 動作のイメージ](#️-動作のイメージ-1)
    - [✅ メリット](#-メリット-1)
    - [⚠️ デメリット](#️-デメリット-1)
  - [🧭 まとめ比較表](#-まとめ比較表)
  - [💡 実用例](#-実用例)
    - [静的 include の例（レイアウト固定）](#静的-include-の例レイアウト固定)
    - [動的 include の例（可変コンテンツ）](#動的-include-の例可変コンテンツ)
- [次の質問](#次の質問)
  - [回答](#回答-1)
  - [1) 条件分岐で `<%@ include %>` を使っている（静的includeは条件を無視）](#1-条件分岐で--include--を使っている静的includeは条件を無視)
  - [2) `<jsp:param>` で値を渡している（静的includeにはパラメータ機能がない）](#2-jspparam-で値を渡している静的includeにはパラメータ機能がない)
  - [3) 断片に `<%@ page %>` や宣言が含まれている（翻訳単位の衝突）](#3-断片に--page--や宣言が含まれている翻訳単位の衝突)
  - [4) パス解決の差異](#4-パス解決の差異)
  - [5) バッファ/フラッシュやレスポンス書き込みのタイミング](#5-バッファフラッシュやレスポンス書き込みのタイミング)
- [実務での指針（おすすめ構成）](#実務での指針おすすめ構成)

## 質問

``` txt
JSPのinclude文2種類
```

---

## 回答

JSP（JavaServer Pages）で使われる `<%@ include %>` と `<jsp:include>` の2種類の「include文」は、どちらも他のファイルを取り込むために使いますが、**タイミングと動作が大きく異なります。**

---

## 🧩 1. 静的インクルード（`<%@ include file="..." %>`）

### 📖 構文

```jsp
<%@ include file="header.jsp" %>
```

### 🔍 特徴

* **翻訳時（コンパイル前）** にファイル内容をそのまま埋め込む。
* JSPファイルが **サーブレットに変換される段階** で結合される。
* つまり、**1つの大きなJSPファイルとしてコンパイル** される。
* 変数やスコープを共有できる（同じJSP内扱い）。

### ⚙️ 動作のイメージ

```
index.jsp
 ├── <%@ include file="header.jsp" %>
 ├── <body> ... </body>
```

→ コンパイル時に `header.jsp` の内容が展開され、1つのJavaソースになる。

### ✅ メリット

* 実行時オーバーヘッドがない（コンパイル時にまとめられる）。
* 共通レイアウトなど、頻繁に変わらない静的部分に最適。

### ⚠️ デメリット

* include先のファイルを変更した場合、再コンパイルが必要。
* 実行中に内容を差し替えたい用途には不向き。

---

## ⚡ 2. 動的インクルード（`<jsp:include page="..." />`）

### 📖 構文

```jsp
<jsp:include page="header.jsp" flush="true" />
```

### 🔍 特徴

* **実行時（リクエスト時）** に指定ファイルを呼び出す。
* 実行時にJSPコンテナが別のサーブレットを呼び出し、その出力結果を取り込む。
* それぞれ独立したスコープ（`request` や `pageContext`）で実行される。

### ⚙️ 動作のイメージ

```
index.jsp
 ├── <jsp:include page="header.jsp" />
 ├── <body> ... </body>
```

→ 実行時に `header.jsp` が呼ばれ、生成されたHTMLを `index.jsp` に挿入。

### ✅ メリット

* include先を動的に変更できる（変数で指定可能）。

  ```jsp
  <jsp:include page="<%= somePage %>" />
  ```
* 更新が即反映される（サーバ再起動不要）。
* 独立した実行環境で安全。

### ⚠️ デメリット

* 実行時にオーバーヘッドがある（サブリクエストが発生）。
* 変数スコープが独立しているため、直接の変数共有はできない。

---

## 🧭 まとめ比較表

| 特徴       | `<%@ include %>`（静的） | `<jsp:include>`（動的） |
| -------- | -------------------- | ------------------- |
| 実行タイミング  | 翻訳（コンパイル）時           | 実行（リクエスト）時          |
| 内容の取り込み  | ソースコードを埋め込み          | 出力結果を取り込み           |
| スコープ共有   | 同一スコープ（共有可）          | 独立スコープ（共有不可）        |
| パフォーマンス  | 高速（1ファイル化）           | やや遅い（実行時呼出）         |
| ファイル更新反映 | 再コンパイル必要             | 即時反映される             |
| 主な用途     | 静的レイアウト              | 動的コンテンツ／モジュール呼出     |

---

## 💡 実用例

### 静的 include の例（レイアウト固定）

```jsp
<%@ include file="/common/header.jsp" %>
<body>
  <h1>Welcome</h1>
</body>
<%@ include file="/common/footer.jsp" %>
```

### 動的 include の例（可変コンテンツ）

```jsp
<jsp:include page="/contents/${pageId}.jsp" />
```

---

希望があれば、この2つを**実際にコンパイル後のサーブレットソースコードで比較**してみせることもできます。やってみますか？


----

# 次の質問

``` txt
新規・詳細表示・更新を共通のjspファイルで対応するとします。jsp:includeで表示できて、<%@ includeでうまく動かないパターンがあるようなのですが、何が原因でしょうか。
```

----

## 回答

原因はだいたい次のどれかです。共通JSPを「新規・詳細・更新」で切り替える構成だと特に①②③が“あるある”です。

---

## 1) 条件分岐で `<%@ include %>` を使っている（静的includeは条件を無視）

```jsp
<c:if test="${mode == 'new'}">
  <%@ include file="/fragments/form.jspf" %>
</c:if>
<c:if test="${mode == 'show'}">
  <%@ include file="/fragments/show.jspf" %>
</c:if>
```

* **静的includeは「翻訳時に結合」** されるため、`<c:if>` の真偽に関係なく **両方の断片が同じ1つのJSPに貼り合わされます**。
* その結果、**重複定義**（例：同じ `id` の `<jsp:useBean>`, `<%! ... %>` の同名メソッド/フィールド、同じ変数名の宣言 など）で **コンパイルエラー** になりがち。
* 一方 `<jsp:include>` は **実行時** に片方だけ呼ばれるため衝突が起こりません。

**対策**

* 条件で切り替えたいなら **`<jsp:include>` を使う**（推奨）。
* もしくは静的includeを使うなら、**断片側（*.jspf）から宣言や重複しうる要素を排除**する（スクリプトレット宣言 `<%! %>` や `<jsp:useBean>` を置かない等）。

---

## 2) `<jsp:param>` で値を渡している（静的includeにはパラメータ機能がない）

```jsp
<jsp:include page="/fragments/form.jsp">
  <jsp:param name="mode" value="${mode}" />
</jsp:include>
```

* これで受け取っている `request.getParameter("mode")` 等は、**`<%@ include %>` では渡せません**。静的includeは“ただのソース貼付け”なので “パラメータ渡し” という概念がない。
* そのため、**`mode` がnullになってNPE**・誤判定などが発生 → 「`jsp:include` だと動くのに、`<%@ include %>` だと壊れる」現象に直結。

**対策**

* 断片に値を渡す必要があるなら、**`request` / `pageContext` の属性で渡す**：

  ```jsp
  <%
    request.setAttribute("mode", mode);
  %>
  <%@ include file="/fragments/form.jspf" %>
  ```

  または **`<jsp:include>` のままにする**。

---

## 3) 断片に `<%@ page %>` や宣言が含まれている（翻訳単位の衝突）

* 静的includeで結合されると、**複数の `<%@ page %>` 指定が混ざる**（`contentType` や `isELIgnored` 等が食い違う）→ 翻訳時エラー。
* `<%! ... %>`（宣言）で **同名メソッド/フィールド** が複数断片にあると **「重複定義」** でコンパイルエラー。
* 同一 `id` の `<jsp:useBean>` も衝突の元。

**対策**

* **断片は “JSPフラグメント（*.jspf）” として、`<%@ page %>` を置かない**。
* **宣言 `<%! %>` は親JSPに集約**し、断片には **プレゼンテーション（HTML/EL/JSTL）だけ** を置く。
* `<jsp:useBean>` は1か所に寄せ、断片では **`EL` で読むだけ** にする。

---

## 4) パス解決の差異

* **`<%@ include file="..." %>`**：`file` が `/` で始まればコンテキストルート相対、そうでなければ **「呼び出し元JSPからの相対」**。
* **`<jsp:include page="..." >`**：`/` で始まればコンテキストルート相対、そうでなければ **「現在のリクエストURI基準」**。
* そのため、**相対パスの書き方が片方でだけ通る** ことがあります。

**対策**

* 迷ったら **絶対パス（`/WEB-INF/...`）で統一**。
* もしくは **呼び出し規約を明確化**（全て“呼び出し元基準”にそろえる等）。

---

## 5) バッファ/フラッシュやレスポンス書き込みのタイミング

* `<jsp:include flush="true">` のような **フラッシュ制御やサブレスポンス合成**は動的include固有の挙動。
* 静的includeでは **1つの翻訳単位としてバッファリング/書き込み順序が変わる**ため、**ヘッダ書き込みや `response.sendRedirect()` のタイミング**がずれて例外になることがあります。

**対策**

* **レスポンスヘッダ操作は親側に集約**。断片では **出力専用** にする。

---

# 実務での指針（おすすめ構成）

* **切替が必要なときは `jsp:include` 一択**（`mode` 等は `<jsp:param>` か `request` 属性で渡す）。
* **静的な共通パーツ（ヘッダ/フッタなど）**は `<%@ include %>` でもOK。ただし **断片は*.jspf** にし、**宣言・`<%@ page %>`・bean生成は置かない**。
* **ロジックはサーブレット/コントローラで完結**させ、JSP断片は **表示に専念**。
* 将来的には **JSTL + EL中心**にし、スクリプトレット宣言を排除。さらに一歩進めるなら **JSPタグファイル** や **テンプレートエンジン（Thymeleaf等）** へ。

---

必要なら、あなたの断片ファイルの抜粋（form/show/editの*.jsp / *.jspf）を貼ってくれれば、**どこが衝突しているか具体的に直し方**まで示します。
